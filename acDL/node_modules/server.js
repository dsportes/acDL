'use strict'

AC.Server = class Server {
	constructor(url, pwd, dirName, onDone, onError){
		if (!url) {
			alert("URL vide/absente");
			throw "URL vide/absente";
		}
		if (url.endsWith("/"))
			url = url.substring(0, url.length -1);
		const https = url.startsWith("https://");
		if (https) {
			this.http = require('https');
			url = url.substring(8);
		} else if (url.startsWith("http://")) {
			this.http = require('http');
			url = url.substring(7);
		} else {
			alert("URL mal formée : " + url);
			throw "URL mal formée : " + url;
		}
		let i = url.indexOf("/");
		let site = url;
		this.path = "/";
		if (i != -1 && i != url.length - 1) {
			site = url.substring(0, i);
			this.path = url.substring(i);
		}
		this.path = this.path.endsWith("/") ? this.path + "admin" : this.path + "/admin";
		i = site.indexOf(":");
		if (i == -1 && i != site.length - 1){
			this.host = site;
			this.port = https ? 443 : 80;
		} else {
			this.host = site.substring(0, i);
			this.port = parseInt(site.substring(i + 1), 10);
		}
		const crypto = require('crypto');
		this.pwd = crypto.createHash('sha1').update(pwd + "00").digest('hex');
		this.dirName = dirName;
		if (!this.dirName.endsWith("/"))
			this.dirName += "/";
		this.filtre = {};
		AC.eventEmitter.on("requestDone", (text) => { if (onDone) onDone(text); });
		AC.eventEmitter.on("requestError", (error) => {	if (onError) onError(error); });
	}

	close(){
		AC.eventEmitter.removeAllListeners("requestDone");
		AC.eventEmitter.removeAllListeners("requestError");
	}

	setFiltre(line, col, version, types) {
		const f = {};
		if (line) f.l = line;
		if (col) f.c = col;
		if (version) f.v = version;
		if (types) f.t = types;
		this.filtre = f;
	}

	onOff(isOn){
		this.filtre = null;
		this.post(this.initQs(isOn ? "on" : "off"));
	}

	linesS(line, version){
		this.setFiltre(line, null, version, null);
		this.post(this.initQs("linesS"));
	}
	
	docsS(line, version){
		this.setFiltre(line, null, version, null);
		this.post(this.initQs("docsS"));
	}
	
	dumpV(line){
		this.filtre = null;
		const qs = this.initQs("dumpV");
		qs.l = line;
		this.post(qs, null, 3, line + "line/Versions.json.gz");
	}
	
	dumpC(line, col, batch){
		this.setFiltre(null, col);
		const qs = this.initQs("dumpC");
		qs.l = line;
		this.post(qs, null, 3, line + "line/B" + batch + ".zip");
	}
	
	dumpS(line, col, version, types){
		this.setFiltre(null, col, version, types);
		const qs = this.initQs("dumpS");
		qs.l = line;
		this.post(qs, null, 1, line);
	}
	
	dumpD(line, versiond){
		this.setFiltre(null, null, versiond, null);
		const qs = this.initQs("dumpD");
		qs.l = line + ".gz";
		this.post(qs, null, 2, line + ".gz");
	}
	
	load(line, fileName, first){
		this.setFiltre(null, first ? null : "1", null, null);
		const qs = this.initQs("load");
		qs.l = line;
		this.post(qs, fileName);
	}
	
	loadD(line, fileName, urlSrc, urlDest){
		this.setFiltre(null, urlSrc, null, urlDest);
		const qs = this.initQs("loadD");
		qs.l = line;
		this.post(qs, fileName);
	}
	
	options(length){
		return {host:this.host, port:this.port, path:this.path, method:'POST', 
			headers:{'Content-Length':length}};
	}
	
	post(qs, fileName, toSave, name){
		this.stream = null;
		const postData = JSON.stringify(qs) + "\n";
		let size = postData.length ;
		let text = "";
		let err = "";
		let resSize = 0;
		let readStream = null;
		if (fileName) {
			try {
				size += AC.fs.statSync(fileName).size;
				readStream = AC.fs.createReadStream(fileName);
			} catch(e) {
				AC.emit("requestError", e.message);
			}
		}
		if (toSave == 1) {
			this.header = this.dirName + name + "_";
		} else if (toSave == 2) {
			let i = name.lastIndexOf("-");
			i = name.lastIndexOf("-", i - 1);
			i = name.lastIndexOf("-", i - 1);
			const d = this.dirName + name.substring(i + 1, i + 5);
			try {
				AC.fs.mkdirSync(d);
			} catch(e) {
			    if (e.code != 'EEXIST') {
			    	AC.emit("requestError", "Création du directory " 
			    			+ d + " impossible :" + e.message);
			    	return;
			    }
			}
			this.stream = AC.fs.createWriteStream(d + "/" + name);
		} else if (toSave == 3){
			const d = this.dirName;
			this.stream = AC.fs.createWriteStream(d + "/" + name);		
		}
		
		const req = this.http.request(this.options(size), (res) => {
			// console.log(`STATUS: ${res.statusCode}`);
			// console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
			if (res.statusCode != 200) {
				res.on('data', (chunk) => {
					err += chunk;
				});
				res.on('end', () => {
					AC.emit("requestError", err);
				});
			} else {
				let nch = 0;
				res.on('data', (chunk) => {
					nch++;
					if (!toSave){
						text += chunk;
					} else if (toSave >= 2){
						this.stream.write(chunk);
						resSize += chunk.length;						
					} else {
						let s = 0;
						if (!this.stream) {
							for(let i = 0; i < chunk.length; i++){
								let c = chunk[i];
								if (!c){
									s = i + 1;
									this.stream = AC.fs.createWriteStream(this.header + ".zip");
									break;
								} else
									this.header += String.fromCharCode(c);
							};
						}
						const b = !s ? chunk : chunk.slice(s);
						this.stream.write(b);
						resSize += b.length;
					};
				});
				res.on('end', () => {
					if (this.stream) {
						this.stream.end();
						AC.emit("requestDone", resSize);
					} else
						AC.emit("requestDone", text);
				});
			};
		});
	
		req.on('error', (e) => { 
			AC.emit("requestError", e.message); 
		});
	
		req.write(postData);
		if (!fileName) {
			req.end();
			return;
		}
		readStream
			.on('data', (chunk) => req.write(chunk))
			.on('end', () => req.end());
	}
	
	initQs(op){
		const qs = {at:-1, ad:0, op:op, ap:this.pwd};
		if (this.filtre) {
			if (this.filtre.l) qs.l = this.filtre.l;
			if (this.filtre.c) qs.c = this.filtre.c;
			if (this.filtre.v) qs.v = this.filtre.v;
			if (this.filtre.t) qs.t = this.filtre.t;
		}
		return qs;
	}
}