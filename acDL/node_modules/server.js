'use strict';

function Server(url, pwd, dirName){
	var https = url.startsWith("https://");
	if (https) {
		this.http = require('https');
		url = url.substring(8);
	} else if (url.startsWith("http://")) {
		this.http = require('http');
		url = url.substring(7);
	} else {
		alert("URL mal formée : " + url);
		throw "URL mal formée : " + url;
	}
	var i = url.indexOf("/");
	var site = url;
	this.path = "/";
	if (i != -1 && i != url.length - 1) {
		site = url.substring(0, i);
		this.path = url.substring(i);
	}
	this.path = this.path.endsWith("/") ? this.path + "admin" : this.path + "/admin";
	i = site.indexOf(":");
	if (i == -1 && i != site.length - 1){
		this.host = site;
		this.port = https ? 443 : 80;
	} else {
		this.host = site.substring(0, i);
		this.port = parseInt(site.substring(i + 1), 10);
	}
	var crypto = require('crypto');
	this.pwd = crypto.createHash('sha1').update(pwd + "00").digest('hex');
	this.dirName = dirName;
	this.filtre = {};
	var events = require('events');
	this.eventEmitter = new events.EventEmitter();
	var self = this;
	this.eventEmitter.on("requestDone", function(error){
		if (self.onDone)
			self.onDone(error);
	});
}

Server.prototype.close = function(){
	this.eventEmitter.removeAllListeners("requestDone");
}

Server.prototype.setFiltre = function(line, col, version, types) {
	var f = {};
	if (line) f.l = line;
	if (col) f.c = col;
	if (version) f.v = version;
	if (types) f.t = types;
	this.filtre = f;
};

Server.prototype.dump = function(line){
	var fs = require("fs");
	var self = this;
	var qs = this.initQs("dumpS");
	qs.l = line;
	var postData = JSON.stringify(qs) + "\n";
	var stream = null;
	var header = this.dirName + line + "_";
	var req = this.http.request(this.options(postData.length), (res) => {
		// console.log(`STATUS: ${res.statusCode}`);
		// console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
		res.on('data', (chunk) => {
			var s = 0;
			if (!stream) {
				for(var i = 0; i < chunk.length; i++){
					var c = chunk[i];
					if (!c){
						s = i + 1;
						stream = fs.createWriteStream(header + ".zip");
						break;
					} else
						header += String.fromCharCode(c);
				}
			}
			stream.write(!s ? chunk : chunk.slice(s));
		});
		res.on('end', () => {
			stream.end();
			self.eventEmitter.emit("requestDone");
		});
	});

	req.on('error', (e) => { 
		self.eventEmitter.emit("requestDone", e.message);
		});

	req.write(postData, null, (e) => { 
		if (e)
			self.eventEmitter.emit("requestDone", e.message);
		});
	req.end();
};

Server.prototype.options = function(length){
	return {host:this.host, port:this.port, path:this.path, method:'POST', 
		headers:{'Content-Length':length}};
};

Server.prototype.initQs = function(op){
	var qs = {at:-1, ad:0, op:op, ap:this.pwd};
	if (this.filtre.l) qs.l = this.filtre.l;
	if (this.filtre.c) qs.c = this.filtre.c;
	if (this.filtre.v) qs.v = this.filtre.v;
	if (this.filtre.types) qs.t = this.filtre.types;
	return qs;
};
