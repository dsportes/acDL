'use strict';

AC.Server = function(url, pwd, dirName, onDone, onError){
	var https = url.startsWith("https://");
	if (https) {
		this.http = require('https');
		url = url.substring(8);
	} else if (url.startsWith("http://")) {
		this.http = require('http');
		url = url.substring(7);
	} else {
		alert("URL mal formée : " + url);
		throw "URL mal formée : " + url;
	}
	var i = url.indexOf("/");
	var site = url;
	this.path = "/";
	if (i != -1 && i != url.length - 1) {
		site = url.substring(0, i);
		this.path = url.substring(i);
	}
	this.path = this.path.endsWith("/") ? this.path + "admin" : this.path + "/admin";
	i = site.indexOf(":");
	if (i == -1 && i != site.length - 1){
		this.host = site;
		this.port = https ? 443 : 80;
	} else {
		this.host = site.substring(0, i);
		this.port = parseInt(site.substring(i + 1), 10);
	}
	var crypto = require('crypto');
	this.pwd = crypto.createHash('sha1').update(pwd + "00").digest('hex');
	this.dirName = dirName;
	this.filtre = {};
	AC.eventEmitter.on("requestDone", function(text){
		if (onDone)
			onDone(text);
	});
	AC.eventEmitter.on("requestError", function(error){
		if (onError)
			onError(error);
	});
}

AC.Server.prototype.close = function(){
	this.eventEmitter.removeAllListeners("requestDone");
}

AC.Server.prototype.setFiltre = function(line, col, version, types) {
	var f = {};
	if (line) f.l = line;
	if (col) f.c = col;
	if (version) f.v = version;
	if (types) f.t = types;
	this.filtre = f;
};

AC.Server.prototype.onOff = function(isOn){
	var postData = JSON.stringify(this.initQs(isOn ? "on" : "off")) + "\n";
	var text = "";
	var req = this.http.request(this.options(postData.length), (res) => {
		res.on('data', (chunk) => {
			text += chunk;
		});
		res.on('end', () => {
			var ev = text.startsWith("$") ? "requestError" : "requestDone";
			AC.eventEmitter.emit(ev, text);
		});
	});

	req.on('error', (e) => { 
		AC.eventEmitter.emit("requestError", e.message);
	});

	req.write(postData, null, (e) => { 
		if (e)
			AC.eventEmitter.emit("requestError", e.message);
	});
	req.end();
};

AC.Server.prototype.dump = function(line){
	var self = this;
	var qs = this.initQs("dumpS");
	qs.l = line;
	var postData = JSON.stringify(qs) + "\n";
	var stream = null;
	var err = "";
	var header = this.dirName + line + "_";
	var req = this.http.request(this.options(postData.length), (res) => {
		// console.log(`STATUS: ${res.statusCode}`);
		// console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
		res.on('data', (chunk) => {
			var s = 0;
			if (!stream) {
				if (err || chunk[0] == 36) { // $
					err += chunk;
				} else {					
					for(var i = 0; i < chunk.length; i++){
						var c = chunk[i];
						if (!c){
							s = i + 1;
							stream = AC.fs.createWriteStream(header + ".zip");
							break;
						} else
							header += String.fromCharCode(c);
					}
				}
			}
			if (!err)
				stream.write(!s ? chunk : chunk.slice(s));
		});
		res.on('end', () => {
			if (!err) {
				stream.end();
				AC.eventEmitter.emit("requestDone");
			} else {
				AC.eventEmitter.emit("requestError", err);				
			}
		});
	});

	req.on('error', (e) => { 
		AC.eventEmitter.emit("requestError", e.message);
	});

	req.write(postData, null, (e) => { 
		if (e)
			AC.eventEmitter.emit("requestError", e.message);
	});
	req.end();
};

AC.Server.prototype.options = function(length){
	return {host:this.host, port:this.port, path:this.path, method:'POST', 
		headers:{'Content-Length':length}};
};

AC.Server.prototype.initQs = function(op){
	var qs = {at:-1, ad:0, op:op, ap:this.pwd};
	if (this.filtre.l) qs.l = this.filtre.l;
	if (this.filtre.c) qs.c = this.filtre.c;
	if (this.filtre.v) qs.v = this.filtre.v;
	if (this.filtre.types) qs.t = this.filtre.types;
	return qs;
};
